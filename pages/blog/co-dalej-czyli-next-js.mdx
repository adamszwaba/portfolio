---
title: Refactoring with empathy - Part 1
description: Refactoring more often than not is a painful process. In this article we'll have a look at how to do it right - and with empathy.
createdAt: 2022-11-20
updatedAt: 2022-11-20
thumbnail: /thumbnails/refactoring-with-empathy.jpeg
---

import ArticleLayout from '../../features/articles/article-layout';

# Intro

[slajd wejściowy]
Jest taki mały podziemny ruch w Code and Pepper, w którym cicho (ale odpowiednio głośno, żeby każdy dookoła
usłyszał) szepczemy o Next.js.
Szepczemy, bo w sumie nam się podoba, bo to framework of choice wielu z nas, do tego stopnia, że z chęcią byśmy coś w nim napisali bardziej oficjalnie niż w ramach riserczu. No to teraz przyszedł czas, że mogę wepchnąć się kulturalnie, ale łokciem i opowiedzieć trochę, co to w ogóle jest i czemu nas to tak bardzo jara.

# SSR vs SPA

[slajd But first history]
...ale najpierw trochę o historii.
Życie bez JSa było ciężkie. Generalnie strony były statyczne, ładowały się powoli, a przejście z jednej strony do drugiej zajmowało dość czasu, żeby w międzyczasie zrobić sobie kawkę, pokrzyczeć na tych, co właśnie zajmowali linię, bo
Gdzieś w zamierzchłych czasach zorientowaliśmy się, że ciągłe przesyłanie htmlowych templatek jest passe, a javascript to całkiem dobra sprawa, jeśli chcemy zrobić coś interaktywnego bez ciągłego wysyłania requestów.
Pojawił się AJAX, jak grzyby po deszczu pojawiły się różne frameworki o których nikt raczej nie pamięta, a jQuery był wszędzie.
Zaczął się czas SPA - single page appek, których czar miał polegać na tym, że strona ładowała się tylko raz, a później już kwadracikami na stronie zajmował się javascript, który robił wszystko.
Javascript zmieniał kolor, wygląd, ułożenie elementów na stronie.
Javascript zbierał dane z formularzy, sprawdzał, czy wszystko w nich bangla i prosił serwer o dane.
Javascript ładował obrazki.
Javascript wywoływal inny javascript, który zmieniał nam tytuł, który kompletnie zmieniał widok, który z kolei wymagał zupełnie innego javascripta, żeby stworzyć nowy formularz, który zbierze odpowiednie inputy, który javascript znowu zwaliduje i znowu poprosi o kolejne dane...

## Frameworki

Generalnie, to tego javascripta było dużo. Na tyle dużo, że, aby uprościć sobie sprawę, pojawiły się frameworki
[slajd z frameworkami]
Pojawił się na przykład angular
[ikona z angularem]
Po jakimś czasie pojawił się React
[ikona Reacta]
Pojawiły się też Vue, Svelte i mnóstwo innych pomniejszych frameworków
[dodać ikonę Vue i Svelte]
I chociaż doświadczenia developerów konsekwentnie stawały się coraz lepsze, zaczęły się pojawiać problemy.

Bo co, jeśli po pierwsze nie potrzebuję tyle javascripta? Co jeśli tworzę prostą stronę i wszystko, czego potrzebuję, to parę splash screenów i widoków z tekstem do mojego bloga albo stronki reklamowej? No i przede wszystkim, co jeśli moja appka jest naprawdę ogromna - wtedy sama wielkość tego początkowego javascripta jest ogromna.

W międzyczasie rozwijały sie też innego typu frameworki, czy to oparte na PHPie, czy na Ruby, które łączyły stare, templatkowe podejście z możliwościami JSa, tworząc bardziej hybrydowe rozwiązania. No, ale do tego trzeba by było znać inne języki, uczyć się C#, Ruby, PHPa, a tego to mi się nie chce.

# Next.js

Tutaj wskakuje Next.js. Developerzy z Vercela mówią 'Hej, co jeśli Ci powiem, że możesz otrzymać mniej JSa przez więcej JSa?' i oferują reactowy framework, który skupia się na wydajności i próbuje tyle, ile może, zafundować Server Side.

## Ogranicz JS użytkownika

W odpowiedzi na rosnącą wielkość jsowych bundli, które nie dość, że znacznie wpływają na wydajność, to przez czas oczekiwania na ściągnięcie paczek wielkości liczonych w megabajtach, Next serwuje nam każdą ze stron, ze zoptymalizowanym osobno bundlem dla każdej, prosto z serwera. Co to oznacza?
[slajd z typowym hero page]
Generalnie - że tam, gdzie nie używamy dużo JSa, albo w ogóle, tam czekamy krócej na stronę. Landing page, strony typu about i typowe komercyjne fillery praktycznie nie posiadają dodatkowego obciążenia, chociaż w samej apce mamy też na przykład bardzo ciężką część dashboardową,
[slajd z dashboardem]
której komponenty są pobierane tylko w razie wejścia na odpowiednią ścieżkę.

[wykres route/waga JSa]
W efekcie - cała e-commercowa aplikacja może mieć ścieżki, na których pobieramy praktycznie zero JSa i ścieżki, na których mogą operować niezależnie całe aplikacje. Niepotrzebny nam dynamic import i code splitting.

## Dane pobieraj tam, gdzie najtaniej

No dobra. Co, kiedy nie jest tak łatwo? Na przykład - mamy apkę oferującą podgląd różnych drużyn piłkarskich. W galeryjce klikamy na manchester i...
[slajd z circularprogress]
widzimy to. Bo wiecie, trzeba pobrać dane, chcemy użytkownikowi pokazać, że już idzie, już biegnie. Potrwa to trochę, ale jak już przemieli, to...
[slajd z circularprogress of circularprogress]
Musi pobrać więcej danych.

Next mówi "Dobra, potrzebujesz takich stron, gdzie chcesz pobrać dane? Niech serwer pobierze, przemieli, wyrzuci, czego nie trzeba, zostawi, co potrzebne i wyświetli, co może." i oferuje data fetching ze strony serwera.

Jakie są tego plusy?
[slajd z bonusami server side data fetching]

- jest szybciej
- jest bezpieczniej - bo nie pokazujemy wszystkiego, tylko to, co chcemy, a niepotrzebne dane nie są nigdzie widoczne
- jest dobrze indeksowalne

Co więcej, takie strony mogą być serwowane dynamicznie - lambdy najpierw pobierają odpowiednie dane, przemielają, a potem wyrzucają html - albo statycznie - w czasie builda samej aplikacji możemy wytworzyć (jak w Gatsbym) - cały zestaw statycznych plików, każdy odpowiadający określonej ścieżce.

## Routing

[slajd z routingiem]
A tak wygląda struktura folderów w takim projekcie. Warto zwrócić uwagę na parę rzeczy.
Po pierwsze, widzimy dwa pliki `_app.tsx` i `_document.tsx` - to pliki, które każdy projekt posiada i określają kształt odpowiednio ogólnie całej apki i całego dokumentu htmlowego na każdej ścieżce.

Przy takim ustawieniu folderów, będziemy mieli dostęp do następujących ścieżek

`/`
`/teams`
`/teams/[region]/` - np. `/teams/uk/`
`/teams/[region]/[teamname]` - np. `/teams/uk/man-utd`

### index.tsx

Pliki `index.tsx` to pliki bezpośrendio opisujące określoną ścieżkę.

### [dynamic-routes].tsx

Zamknięcie nazwy pliku lub folderu w kwadratowych nawiasach sprawia, że ścieżki stają się dynamiczne i możemy określać, jak odpowiedzą na podstawie dynamicznych parametrów. Możemy na przykład określić, że w przypadku `/teams/[region]` serwer ma pobrać dane na temat teamów z podanego regionu, a potem przekazać je stronie, która wygeneruje listę linków do lig i teamów, podobnie postępując w przypadku próby dostępu do odpowiedniego teamu.

## Optymizuj, gdzie się da

Znacie to uczucie, kiedy odpalacie stronę i widzicie to
[slajd ze stroną z samym tekstem]
z widocznym CTA, który klikacie i dokładnie w tym momencie macie
[slajd z tą stroną i hero, który zajmuje miejsce poprzedniego CTA]
co wywołuje to
[slajd z circular progress]
bo akurat hero image to jakiś link i nie wiadomo, co to było?

Generalnie, żeby tego uniknąć, w zwykłej aplikacji robimy parę upierdliwych rzeczy:

1. Konwertujemy każdy asset na lżejszy format, jak webp, ale z tym jest problem, bo nie każdy browser obsługuje webp. [slide z folderem assets z jednym bigPicture.webp]
2. Przygotowujemy wersje tego samego obrazka dla paru różnych breakpointów, np. 300, 768 i 1280px [slide z folderem assets z trzema plikami webp dla kazdego breakpointa]
3. Zrobić jakiś dziwny hack z JSem.

Next? Wszystko, co trzeba zrobić, to skorzystać z ich komponentu `Image` i nie musimy robić żadnej z tych rzeczy. [slide z easy folderem i next/image]
Można oczywiście customizować, co chcemy - wysokość, sposób, w jaki się ładuje. Jak to działa? Dla każdego `Image` tworzona jest lambda, która wykouje tę magię na bieżąco, konwertując, jeśli browser na to pozwala, obrazek na nowoczesny format, tworzy zestaw obrazków dla odpowiednich breakpointów i koniec końców funduje nam dostępny, czysty tag img.

## Typescript?

Jasne! Gdzie JS, tam TS, a dodatkowo cały framework jest porządnie otypowany, toteż nie ma się co przejmować brakiem type-safety.

## Bezpieczeństwo

[slajd z widocznością kluczy w SPA - klucz do API -> .env -> bundle.js]
Żeby korzystać z API, zwykle potrzebuję do niej klucza. Jak podać klucz? Pewnie gdzieś w envach, koniec końców zostanie tak czy siak zamknięty w klienckim bundlu. I tutaj zaczyna się pojawiać kwestia bezpieczeństwa. Nawet, jeśli bardzo się postaramy - to i tak pozostaje w pewnym stopniu dostępny dla użytkownika.

[slajd z widocznością kluczy w SPA - klucz do API -> .env -> NEXT_PUBLIC_...? -> browser : Next server]
Ponieważ Nextowa apka stoi na serwerze, nie musi eksponować wszystkiego do bundla. Jeśli dokładnie nie oznaczymy, że chcemy, aby browser miał dostęp do tej zmiennej, zostanie ona zachowana tylko i wyłącznie dla użytku serwera.
[slajd klucze autoryzacyjne, sekrety awsowe, database host -> ukryte ]
Czy to klucze do Auth0, awsowe sekrety, czy adresy baz danych, może być ukryte dla użytkownika i dostępne tylko z poziomu serwera.

## API routes - interfejs między apką a API

No dobra, ale skoro nie po stronie klienckiej, to gdzie mogę korzystać?

[slajd ze zdjęciem routów]
Next udostępnia nam możliwość tworzenia api routów, czyli sposób na rozszerzenie możliwości serwera, na którym stoi webowa appka, na wszystko, na co pozwala node'owy serwer, dodatkowo poszerzając to o między innymi `dynamic routes`, czyli routy przyjmujące dynamiczne parametry w podobny sposób, jak w przypadku podstron.

# Nasze use-casy:

Bo po co o tym gadać, jak nam niepotrzebne, nie?

## Manipulacja konfiguracją webpacka

Znacie aliasy. To ta rzecz, która pozwala nam na dostęp do folderu komponentów bez wpisywania pięćdziesięciu kropek i pamiętania, jak głęboko jesteśmy zagnieżdżeni. A potem poprawiania, bo jednak zaczęliśmy szukać poza folderem. Taka sprawa.
[slajd z aliasami]
Chcesz użyć aliasów przy create-react app?
Nie ma tak łatwo.
Po pierwsze - nie ma mowy, żebyś legalnie kombinował z konfiguracją webpacka.
Chcesz? To musisz ejectnąć albo polegać na paczkach, które niejako hackują cra, żeby jednak pozwolić na konfigurację webpacka.
Ejectnąć? To Cię React potraktuje wielką informacją, że może nie powinieneś, że w większości przypadków nie musisz, a jak już to zrobisz, to nie wrócisz.
Użyjesz paczki? Spoko. Tylko tego, co jak webpack podskoczy i chcesz podbić wersję reacta, a react-app-rewired nie został jeszcze zupdatowany? No i czasem zdarzają się konflikty i bagusie w samej implementacji, a fajnie by było jednak móc polegać na czymś sprawdzonym...

### next.config.js

[gif z rycerzem na białym koniu]
No i tutaj Next wpada cały na biało i daje nam opcję przerobienia webpacka na taki, jaki chcemy, korzystając z `next.config.js` - pliku, który jest w każdym nextowym projekcie, a który pozwala między innymi na customizację webpacka, określenie sposobu kompresji, prefixów assetów, jeśli na przykład chcemy korzystać z cdna i mnóstwa innych rzeczy. Dokumentacja tego configa jest duża, pozwala na wiele i oznacza, że kurde, chociaż wciąż musimy kojarzyć o co chodzi z tymi loaderami i modułami, to nie musimy szukać paczek z trzeciej ręki, żeby móc podać svg.

...których obsługa jest swoją drogą wbudowana w Nexta od ręki.
[dodać ikonkę SVG z koroną nagrody emoji]

## Autentykacja i protected routes

Mamy duże szczęście, że Next przychodzi wraz z ogromnym dobrodziejstwem jakim jest duże wsparcie tzw. community i ogromna ilość narzędzi spreparowanych specjalnie dla samego frameworka. Z racji, że lwia część e-commerca korzysta z tego albo Gatsby'ego, to narobiło się też mnóstwo sprawdzonych w boju narzędzi. Podobnie jest z atutentykacją.
[slajd z NextAuth]
Tutaj bardzo przydaje się `NextAuth`, paczka bezpiecznie, bezpośrednio dla Nexta obsługująca strategie autoryzacyjne dla prawie sześćdziesięciu providerów, włącznie z AWS Cognito i Auth0.
No i pamiętacie ten szpil z dynamicznymi ścieżkami i routingiem? Możemy zabezpieczyć każdą ścieżkę, lub tylko te, które chcemy.

[slajd z tymi materiałami]
Dostajemy:

- rozwiązanie od ręki
- dla wielu providerów
- z obsługą i maintenancem dużej społeczności

## Co z AWSem?

[do slajdu dodać okejkę z ikoną awsa]
Działa. I da się postawić z naszym stackiem bez problemu.

# Co jeszcze?

[slajz tymi pytaniami]

## Czy robienie w Next.js znaczy, że nie możemy zrobić już SPA?

Nie, wcale tego nie znaczy. Jeśli określimy tylko jeden page, to zostanie on zredukowany do jednego bundla i tak, czy siak będzie to SPA. Po wybudowaniu apki, możemy ją też wyeksportować do statycznych assetów i hostować np. przez s3. A dostęp do np. dynamic importów i generalnie reactowego code-splittowania pozostaje. Next nie dość, że współpracuje z nowymi wersjami reacta, to też team współpracuje z facebookiem nad rozwojem wspólnych ficzerów.

### Czy wszystko musi być server-rendered?

Nie. Raz, że nie wszystko trzeba robić SSR, dwa, że w obrębie danej ścieżki możemy zamknąć tyle logiki, ile chcemy. Przejścia typu shallow - czyli bez reloadu strony - to też ficzer dostępny od ręki w Nexcie, więc jeśli wciąż chcemy trzymać się tego samego routa, a tylko udawać inny - nie ma problemu.

### Czy mogę używać mojego react-routera?

Yes. But why?

![hi](https://picsum.photos/200/300)

```tsx
<Some Article />;
const AppBar: React.FC = () => {
  return (
    <nav className="w-full py-4">
      <div className="container flex items-center justify-between">
        <NextLink href="/" className="flex items-center">
          <Logo width={32} height={32} />
          <span className="border-l-stone-600 border-l-[1px] ml-3 h-7 pl-3 flex-grow hover:underline">
            @Adam Szwaba
          </span>
        </NextLink>
        <NextLink
          href="https://github.com/adamszwaba/portfolio"
          className="flex gap-2 items-center bg-slate-200 px-2 py-1 hover:bg-slate-300 transition-colors duration-200 rounded-sm"
        >
          <FaGithub width={24} height={24} />
          Source
        </NextLink>
      </div>
    </nav>
  );
};
```

> [dodać ikonkę z komentarzem]

export default ({ children }) => <ArticleLayout>{children}</ArticleLayout>;
